# C Nebula

## 1. 팀 소개

### 팀장 : 김준형
- 업무 : 프론트엔드, 백엔드, CSS


### 팀원 : 김성은
- 업무 : 백엔드, CSS ,프론트엔드


## 2. 기획 서론

### 2-1. 기획 배경

영화를 대주제로 영화 추천 알고리즘 기반 커뮤니티 서비스를 제작하는 것을 목표로 웹 사이트를 제작하였습니다.

서비스 이름은 C_Nebula로 성운(Nebula)에서 많은 별이 태어나는 것처럼 영화에 대한 사람들의 스토리나 이야기가 탄생하는 공간이라는 의미와 영화 커뮤니티임을 알 수 있도록 Cinema의 Cine와 비슷하도록 C_를 붙였습니다.

### 2-2. 기획 목표

여러가지 기준으로 영화를 추천받고 사용자 간의 좋아요, 팔로우 기능으로 소통할 수 있으며 활동에 대한 포인트도 얻을 수 있습니다. 

### 2-3. 개발 환경

#### 2-3-1. Back-end Framework 

    Django 3.2.13, Django REST Framework

#### 2-3-2. Front-end Framework

    Vue vue/cli 5.0.8

#### 2-2-3. 개발 기간

    22.11.15 ~ 22.11.24 (9일)

## 3. MVP 소개
MVP는 총 4가지로 영화 추천 알고리즘과 게시글을 기반으로 하는 커뮤니티와 유저 개인 페이지 구현을 중점으로 구성되어 있습니다.

### 3-1. 영화 추천 알고리즘

먼저, 영화 정보는 TMDB의 API를 활용하여 popularity 카테고리의 영화를 1000개를 가져왔습니다.
처음 기획 시 총 4가지 기준의 영화 추천 알고리즘을 구현하고자 하였습니다.

1. 금주의 HOT 영화
   - 금일을 기준으로 지난 일주일동안의 서비스 내에 리뷰, 저널에 많이 참조된 영화를 추천합니다.
   - `date`와 `timedelta`을 import하여 게시물 생성일을 비교하였고 `.count()`를 이용하여 리뷰와 저널 작성에 가장 많이 참조된 영화 순으로 출력합니다.
2. 사용자가 팔로잉한 사람들이 좋아하는 영화를 인기도 순으로 추천
   - 사용자의 팔로잉 목록에서, 팔로잉들이 좋아요한 영화를 많이 참조된 순으로 출력합니다.
3. 사용자의 좋아요를 기반으로 한 장르 영화를 인기도 순으로 추천
   - 사용자가 좋아요한 영화를 기반으로 가장 많이 좋아요한 장르의 영화를 인기도(popularity) 순으로 출력합니다.
4. TMDB의 popularity를 기반으로 인기 영화 추천
   - 기본 데이터의 popularity를 조회하여 높은 순으로 출력합니다.


### 3-2. 영화 커뮤니티

검색 혹은 추천으로 화면의 영화 카드를 선택하면 영화 디테일 페이지로 이동합니다. 

영화 디테일 페이지에서는 사용자가 한줄평의 형식인 리뷰를 남길 수 있고, 서로의 리뷰에 좋아요를 남길 수 있습니다.

영화 디테일 페이지 구성 요소는 다음과 같습니다.

1. 영화 상세 정보
    1. 제목 및 줄거리, 개봉일자, 러닝타임
    2. 포스터
    3. 평점
2. 리뷰
   - 리뷰는 댓글 형태로, 영화에 대한 별점과 한줄평을 남길 수 있습니다. 사용자들은 서로의 리뷰에 좋아요를 할 수 있습니다.
    1. like 기능
        - 다른 사용자의 리뷰 내용에 좋아요할 수 있습니다.
    2. 별점 기능
        - 리뷰를 작성마다 사용자의 별점을 받아 해당 영화의 평점을 재계산합니다.
        - 평점 재계산에는 DB의 `vote_average`와 `vote_count`를 활용합니다.

### 3-3. 개인 별 영화 저널 페이지

사용자가 영화 감상평을 올릴 수 있도록 구성하여 다른 유저와의 소통을 좀 더 강화합니다.

1. 게시물을 남기고 싶은 영화를 선택하여 저널을 작성할 수 있습니다.
2. 개인 저널 페이지에 등록한 게시글은 프라이빗 기능을 제공
   - 비공개, 전체 공개
   - 비공개를 선택한 저널은 본인만 볼 수 있습니다.

### 3-4. 개인 별 프로필 페이지
프로필 페이지에서는 개인별 팔로워 및 팔로잉을 확인할 수 있고, 본인이 작성한 저널과 좋아요 한 영화를 모아서 볼 수 있습니다.
1. 다른 사용자의 닉네임을 클릭하면 해당 사용자의 프로필 페이지로 이동할 수 있습니다.
   - 프로필 페이지에서는 해당 유저의 활동 내역을 확인할 수 있습니다.
     - 작성한 저널, 좋아요 한 영화를 살펴볼 수 있습니다.
     - 팔로우와 팔로잉 목록을 확인할 수 있습니다.
2. 포인트 시스템으로 활동 시 포인트를 얻습니다.
   - 좋아요를 받거나 팔로워가 생기면 30점을, 저널을 작성하면 20점을, 리뷰를 작성하면 10점을, 댓글을 작성하면 5점을 얻습니다.
   - 프로필 페이지에서 사용자의 포인트를 확인할 수 있습니다.
   - 추후 포인트에 따른 등급을 제공할 예정입니다.



## 4. 서비스 상세 소개

### 4-1. 폴더 구조

### 4-2. 데이터베이스 모델링 (ERD)
![ERD](https://lab.ssafy.com/jh8671/C_Nebula/-/raw/master/ERD.png)

### 4-3. 검색
검색기능 구현에는 python `fuzzywuzzy` 라이브러리의 `token_sort_ratio`메서드와 `partial_ratio` 메서드를 사용하였습니다.
먼저 Vue에서 사용자가 입력할 때마다 axios 요청을 보냅니다. Django에서는 axios 요청을 받으면 target 단어를 받아 검사를 실시합니다.
DB의 영화 목록을 순회하면서 각 영화의 title과 target 간의 유사도를 검사합니다.
유사도를 검사하기 전, `replace` 메서드로 각각의 문자열 간 공백을 제거합니다. 그리고 `token_sort_ratio` 메서드로 유사도가 40 이상인 영화들을 검사합니다. 또한 `partial_ratio`가 100인 영화도 추가해줍니다. 이후 heaq에 partial_ratio, popularity의 순서로 내림차순 정렬하여 최종 상위 10개 항목을 반환합니다.

### 4-4. 추천 알고리즘 설명
#### 4-4-1. 금주의 HOT 영화
1. 추천 기준 : 오늘을 기준으로 지난 일주일동안 저널에 가장 많이 참조되고 리뷰가 많이 작성된 영화 순으로 출력합니다.
2. 알고리즘 설명
   1. '오늘'에 대한 데이터, today를 date 모듈을 이용하여 받습니다.
   2. __gte로 저널, 리뷰가 작성된 시간(created_at)과 오늘의 시간 차이가 7일 이하인 항목만 필터링하여 가져옵니다.
   `items = Item.objects.filter(created_at__gte=today-timedelta(days=7))` 
   3. 필터링한 저널들과 리뷰들을 각각 순회하면서 영화와의 참조 관계를 이용하여 각각의 저널과 리뷰가 참조하고 있는 영화 목록을 가져와 movies 리스트에 추가해줍니다.
    ```python
        for journal in journals:
        movie = Movie.objects.get(pk=journal.movie_id)
        movies.append(movie)
    ```
   4. movies에 담긴 영화들이 각각 몇번 참조되었는지 확인하기 위해 count() 메서드를 사용합니다.
      1. 각 영화의 popularity를 movies 리스트 안에 영화가 몇개 들어있는지로 판단합니다.
        - `popularity = movies.count(movie)`
   5. 이후 weekly_movies 리스트에 내림차 순으로 heappush합니다. popularity가 같을 경우, vote_average(평점)이 더 높은 영화를 우선 출력합니다.
        - `heappush(weekly_movies, (-popularity, -movie.vote_average, movie))`
        - popularity와 vote_average에 '-'을 붙임으로 내림차순이 될 수 있도록 합니다.

#### 4-4-2. 팔로잉들이 좋아요한 영화
1. 추천 기준 : 사용자가 팔로우한 유저들(사용자의 팔로잉)이 좋아요를 누른 영화들을 좋아요 > 평점 > 인기도의 순으로 정렬하여 추천합니다.
2. 알고리즘 설명
   1. 참조 관계를 이용하여 사용자(user)의 팔로잉 목록을 불러옵니다.
   2. 각 팔로잉들을 순회하면서 movie와의 참조 관계를 이용하여 좋아요 누른 영화 목록을 가져옵니다.
   ```python
    for following in followings:
        movies = following.like_movies.all()
        followings_movies += movies
   ```
   3. followings_movies에 담긴 영화들이 각각 몇 번 참조되었는지 확인하기 위해 count() 메서드를 사용합니다.
   4. 각 영화의 popularity는 followings_movies 리스트 안에 영화가 몇개 들어있는지와 평점, 인기도를 가중치주어 더한 값을 사용합니다. 
       - count 값에는 15, 평점에는 10, 인기도에는 5의 가중치를 주어 팔로잉들의 좋아요가 더 큰 영향을 미칠 수 있도록 하였습니다.
   5. popularity를 기준으로 정렬한 뒤, 상위 10개 항목을 출력합니다.

#### 4-4-3. 좋아요를 기반으로 한 장르 추천
1. 추천 기준 : 사용자가 좋아요 누른 영화들의 장르를 기반으로 인기도 높은 영화를 출력합니다.
2. 알고리즘 설명
   1. 내가 좋아요 누른 영화를 참조관계를 이용하여 가져옵니다.
   `my_movies = user.like_movies.all()`
   2. my_movies를 순회하면서 영화의 장르를 가져와 my_genres 리스트에 추가합니다.
   3. 이후 해당 genre들을 가지고있는 영화 목록을 가져옵니다.
   4. 영화들의 popularity를 기준으로 정렬하여 상위 10개 항목을 출력합니다.

### 4-5. 저널
#### 4-5-1. 저널 작성
- 저널은 유저가 관람한 영화에 대한 감상을 게시글 형태로 작성할 수 있습니다.
- 저널 작성 시 비밀글 여부를 선택할 수 있으며 비밀글로 설정한 저널은 본인만 확인할 수 있습니다.
- 저널 작성 시 글을 남기고자 하는 영화를 검색하여 선택할 수 있습니다.
- 저널 작성 시 별점을 남길 수 있고, 사용자가 부여한 별점을 토대로 DB의 영화 평점(vote_average)을 재계산 합니다.
- 전체공개인 저널에는 다른 사용자가 좋아요를 누를 수 있고, 댓글과 대댓글을 남길 수 있습니다. 
#### 4-5-2. 저널 리스트 보기 기준
총 3가지의 기준으로 저널 리스트를 확인할 수 있습니다.
최신순, 오래된순, 인기순으로 출력합니다.
최신순과 오래된순은 저널의 id 값을 이용하여 내림차순, 오름차순으로 출력합니다.
인기순은 저널이 받은 좋아요와 저널에 작성된 댓글과 대댓글의 개수를 종합하여 측정한 인기도를 기준으로 상위 항목부터 출력합니다. 인기도 측정은 좋아요에 3, 댓글에는 2의 가중치를 주어 합한 값 입니다.


### 4-6. 유저 경험
#### 4-6-1. 유저 프로필
- 저널, 댓글, 리뷰의 작성자 닉네임을 클릭하면 작성자의 프로필 페이지로 이동할 수 있습니다.
- 프로필 페이지에서는 해당 유저의 활동 점수, 팔로워/팔로잉 숫자와 목록, 작성한 저널 목록, 좋아요 누른 영화를 확인할 수 있습니다.

#### 4-6-2. 좋아요
- 좋아요는 영화, 리뷰, 저널, 저널의 댓글에서 가능합니다.
- 영화의 좋아요는 추천 시스템 및 유저 프로필 페이지에서 사용합니다.
- 리뷰 좋아요는 베스트 리뷰를 출력하는 데에 사용합니다.
- 저널 좋아요는 저널 페이지에서 저널의 출력 순서를 좋아요(인기순)으로 출력하는데 사용합니다.

#### 4-6-3. 팔로우
- 각 유저는 서로 팔로우를 할 수 있습니다.
- 팔로워를 얻는 유저는 포인트를 얻습니다. 
- 팔로우를 많이 할수록 팔로잉의 추천이 활발해질 수 있습니다.

#### 4-6-4. ranking 시스템
- 유저의 활동에 따라 포인트를 얻습니다. 프로필에 유저의 포인트를 확인할 수 있으며, 유저 랭킹 페이지에서 본인의 활동 순위를 확인할 수 있습니다.
- 활동이 활발한 유저는 '금주의 우주고양이'가 될 수 있습니다.
- nav 바에 활동이 활발한 유저를 출력합니다.



## 5. 기타
### 5-1. 후기
#### 김성은
멋있는 백엔드 개발을 하고싶어서 나름대로 열심히 했지만 역시 마지막에는 아쉬움이 남네요.
처음에 API로 데이터를 받아오는 것부터 막막했지만 하나하나 배워가고 구현해나가면서 웹 개발에 재미를 붙이게 되었습니다.
물론 아직 아쉬움이 많지만.. 제일 후회되는 점은 프론트엔드와의 소통이 생각보다 적었던 점입니다. 소통을 잘 하고 있다고 생각했는데 백에서 전달되는 데이터가 프론트에서는 어떤 구조로 흐르고있는지 제대로 확인하지 않은 점이 후반부 수정 작업에서 애를 먹은 요인이었습니다. 시작하기 전에 서로 어떤 구조로 프로젝트를 구현할 것인지에 대한 논의가 사실은 충분하지 않았다는 생각입니다.. 다시 한번 소통이 참 중요하다는 것을 깨닫게 된 것 같습니다. 그래도 그 외의 것들, 아이디어나 해결해야 할 이슈들에 대한 소통은 활발했어서 나름 원활히 프로젝트가 진행될 수 있었습니다.
그리고 걱정이 조금 많은 편이지만 프론트엔드를 꽤나 잘하고 꼼꼼한 페어 준형오빠 덕에 구색을 갖춘 웹을 구현할 수 있었습니다.
(저의 B급 감성 -우주고양이- 에 어울려줘서 정말 고맙)

추천 알고리즘을 만들 때 지난 4개월동안 배운 알고리즘 실력이 꽤나 부끄러웠습니다. 검색을 어떻게하면 더 빠르고 정확하고 효율적으로 할 수 있을지, 어떻게 데이터를 더 잘 정제하고 처리할 수 있을지 고민해봤지만 머릿속에서 나오는 해결책은 딱히 괜찮지는 않았습니다. 
(아직도 검색 알고리즘은 많이 부끄럽네요) 그래도 프로젝트 기간동안 추천 알고리즘을 많이 검색하고 읽어본 덕에 새로운 관심사가 생겼습니다. 다 해낼 수 있을지 모르겠지만 조금씩 데이터 공부를 해보고 싶습니다. 

제일 아쉬운 점은 보안입니다. 아직까지 제대로 이해하지 못하고 데코레이터를 붙이고, vue router에 의존한 점이 아쉽고 부끄럽습니다. 그렇기 때문에 공부할 것이 더 늘었네요! 2학기가 시작하기 전까지 실력을 보충해야겠습니다. 

다시 한 번, 너무나 즐거운 프로젝트였습니다!



#### 김준형

첫 프로젝트라서 그런지, 다소 정신없는 10일을 보낸 것 같습니다.

배운 것들을 100퍼센트 활용하지 못한 상황에서 여러 돌발 에러나 처음보는 에러들에 대응해야 했던 점이 저를 가장 당황하게 만들었던 점이었습니다.

그래도 백엔드를 맡아 준 성은이가 좋은 알고리즘과 탄탄한 검색엔진을 만들어 프로젝트의 핵심을 구현해준 덕분에 어떻게든 프로젝트가 완성 될 수 있었던 것 같습니다.

아쉬움이 남는 것은 계획 및 구현 단계에서 너무 정돈되지 않아서, 나중에 디버깅을 하거나 구조를 수정하는데에 있어서 불필요한 시간들이 많이 들었다는점입니다. 일부는 현재 실력으로 실현하기 어려운 기능에 욕심을 내다가 중간에 내용을 수정해야 하는 일들이 더러 있었고, 그때마다 마치 누더기 처럼 기워가는 바람에 조금씩 지저분해졌던 것 같습니다. 계획 단계서부터 할 수 있는것과 없는 것을 확실히 조사 및 구분하고, 변수명 하나하나까지 구체적으로 통일 하여 계획을 세우면 훨씬 개발이 수월해지겠다는 교훈을, 이번 프로젝트를 통해 뼈저리게 느꼈습니다.

또한 아직 백/프론트의 진로를 잡지 못한 상태에서 프론트를 맡게 되었습니다만, 훗날 프론트로서의 커리어를 이어나간다고 해도, 백엔드 개발에 대한 최소한의 이해는 키워둬야 할 것 같다는 생각이 들었습니다. 백엔드 쪽에서의 개발이 매우 빠르게 진척되어서, 이를 쫓아가는 과정에서 백에서 구현된 로직이나 반환값, 모델과 시리얼라이저 등을 직접 참조하면서 맞추는 것, 간혹 프론트와 백의 싱크가 맞지 않는 경우, 어느쪽을 수정하는 것이 더욱 효율적이고 효과적인지에 대한 판단을 하기 위해서는, 백이 무엇이 가능하고 프론트가 무엇이 가능한지, 또 얼마나 효과적인지를 알아야 되겠다는 생각이 들었습니다. 앞으로 어떤 커리어를 쌓게 될지는 모르지만, 계속해서 양쪽의 프레임워크나 로직에 대한 이해는 키워나가는 것이 좋겠다는 생각을 다시한번 해보았습니다.

다시한번, 부족한 저를 지탱해주었던 페어와 항상 조언 해주시는 교수님, 서로서로 도와가며 성장하는 6반 모두에게 감사드립니다. 
